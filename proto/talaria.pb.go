// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: talaria.proto

package talaria

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IngestRequest represents an ingestion request.
type IngestRequest struct {
	// Types that are valid to be assigned to Data:
	//	*IngestRequest_Batch
	//	*IngestRequest_Orc
	//	*IngestRequest_Csv
	//	*IngestRequest_Url
	Data isIngestRequest_Data `protobuf_oneof:"data"`
}

func (m *IngestRequest) Reset()      { *m = IngestRequest{} }
func (*IngestRequest) ProtoMessage() {}
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{0}
}
func (m *IngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest.Merge(m, src)
}
func (m *IngestRequest) XXX_Size() int {
	return m.Size()
}
func (m *IngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest proto.InternalMessageInfo

type isIngestRequest_Data interface {
	isIngestRequest_Data()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IngestRequest_Batch struct {
	Batch *Batch `protobuf:"bytes,1,opt,name=batch,proto3,oneof" json:"batch,omitempty"`
}
type IngestRequest_Orc struct {
	Orc []byte `protobuf:"bytes,2,opt,name=orc,proto3,oneof" json:"orc,omitempty"`
}
type IngestRequest_Csv struct {
	Csv []byte `protobuf:"bytes,3,opt,name=csv,proto3,oneof" json:"csv,omitempty"`
}
type IngestRequest_Url struct {
	Url string `protobuf:"bytes,4,opt,name=url,proto3,oneof" json:"url,omitempty"`
}

func (*IngestRequest_Batch) isIngestRequest_Data() {}
func (*IngestRequest_Orc) isIngestRequest_Data()   {}
func (*IngestRequest_Csv) isIngestRequest_Data()   {}
func (*IngestRequest_Url) isIngestRequest_Data()   {}

func (m *IngestRequest) GetData() isIngestRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *IngestRequest) GetBatch() *Batch {
	if x, ok := m.GetData().(*IngestRequest_Batch); ok {
		return x.Batch
	}
	return nil
}

func (m *IngestRequest) GetOrc() []byte {
	if x, ok := m.GetData().(*IngestRequest_Orc); ok {
		return x.Orc
	}
	return nil
}

func (m *IngestRequest) GetCsv() []byte {
	if x, ok := m.GetData().(*IngestRequest_Csv); ok {
		return x.Csv
	}
	return nil
}

func (m *IngestRequest) GetUrl() string {
	if x, ok := m.GetData().(*IngestRequest_Url); ok {
		return x.Url
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IngestRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IngestRequest_Batch)(nil),
		(*IngestRequest_Orc)(nil),
		(*IngestRequest_Csv)(nil),
		(*IngestRequest_Url)(nil),
	}
}

// IngestResponse represents an ingestion response.
type IngestResponse struct {
}

func (m *IngestResponse) Reset()      { *m = IngestResponse{} }
func (*IngestResponse) ProtoMessage() {}
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{1}
}
func (m *IngestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestResponse.Merge(m, src)
}
func (m *IngestResponse) XXX_Size() int {
	return m.Size()
}
func (m *IngestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IngestResponse proto.InternalMessageInfo

// Batch represents an event batch. It contains a map of strings in order
// to minimize the size.
type Batch struct {
	Strings map[uint32][]byte `protobuf:"bytes,1,rep,name=strings,proto3" json:"strings,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Events  []*Event          `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *Batch) Reset()      { *m = Batch{} }
func (*Batch) ProtoMessage() {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{2}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return m.Size()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetStrings() map[uint32][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Batch) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// Event represents a single event. Name as well as value columns are
// interned strings which are present in a batch.
type Event struct {
	Value map[uint32]*Value `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{3}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetValue() map[uint32]*Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Value represents a value
type Value struct {
	// Types that are valid to be assigned to Value:
	//	*Value_Int32
	//	*Value_Int64
	//	*Value_Float64
	//	*Value_String_
	//	*Value_Bool
	//	*Value_Time
	//	*Value_Json
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()      { *m = Value{} }
func (*Value) ProtoMessage() {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{4}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Value interface {
	isValue_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_Int32 struct {
	Int32 int32 `protobuf:"varint,1,opt,name=int32,proto3,oneof" json:"int32,omitempty"`
}
type Value_Int64 struct {
	Int64 int64 `protobuf:"varint,2,opt,name=int64,proto3,oneof" json:"int64,omitempty"`
}
type Value_Float64 struct {
	Float64 float64 `protobuf:"fixed64,3,opt,name=float64,proto3,oneof" json:"float64,omitempty"`
}
type Value_String_ struct {
	String_ uint32 `protobuf:"varint,4,opt,name=string,proto3,oneof" json:"string,omitempty"`
}
type Value_Bool struct {
	Bool bool `protobuf:"varint,5,opt,name=bool,proto3,oneof" json:"bool,omitempty"`
}
type Value_Time struct {
	Time int64 `protobuf:"varint,6,opt,name=time,proto3,oneof" json:"time,omitempty"`
}
type Value_Json struct {
	Json uint32 `protobuf:"varint,7,opt,name=json,proto3,oneof" json:"json,omitempty"`
}

func (*Value_Int32) isValue_Value()   {}
func (*Value_Int64) isValue_Value()   {}
func (*Value_Float64) isValue_Value() {}
func (*Value_String_) isValue_Value() {}
func (*Value_Bool) isValue_Value()    {}
func (*Value_Time) isValue_Value()    {}
func (*Value_Json) isValue_Value()    {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetInt32() int32 {
	if x, ok := m.GetValue().(*Value_Int32); ok {
		return x.Int32
	}
	return 0
}

func (m *Value) GetInt64() int64 {
	if x, ok := m.GetValue().(*Value_Int64); ok {
		return x.Int64
	}
	return 0
}

func (m *Value) GetFloat64() float64 {
	if x, ok := m.GetValue().(*Value_Float64); ok {
		return x.Float64
	}
	return 0
}

func (m *Value) GetString_() uint32 {
	if x, ok := m.GetValue().(*Value_String_); ok {
		return x.String_
	}
	return 0
}

func (m *Value) GetBool() bool {
	if x, ok := m.GetValue().(*Value_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Value) GetTime() int64 {
	if x, ok := m.GetValue().(*Value_Time); ok {
		return x.Time
	}
	return 0
}

func (m *Value) GetJson() uint32 {
	if x, ok := m.GetValue().(*Value_Json); ok {
		return x.Json
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_Int32)(nil),
		(*Value_Int64)(nil),
		(*Value_Float64)(nil),
		(*Value_String_)(nil),
		(*Value_Bool)(nil),
		(*Value_Time)(nil),
		(*Value_Json)(nil),
	}
}

// DescribeRequest represents an request to list the tables and schemas.
type DescribeRequest struct {
}

func (m *DescribeRequest) Reset()      { *m = DescribeRequest{} }
func (*DescribeRequest) ProtoMessage() {}
func (*DescribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{5}
}
func (m *DescribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DescribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DescribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeRequest.Merge(m, src)
}
func (m *DescribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *DescribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeRequest proto.InternalMessageInfo

// DescribeResponse represents an response that returns tables and their schemas.
type DescribeResponse struct {
	Tables []*TableMeta `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables,omitempty"`
}

func (m *DescribeResponse) Reset()      { *m = DescribeResponse{} }
func (*DescribeResponse) ProtoMessage() {}
func (*DescribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{6}
}
func (m *DescribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DescribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DescribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeResponse.Merge(m, src)
}
func (m *DescribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *DescribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeResponse proto.InternalMessageInfo

func (m *DescribeResponse) GetTables() []*TableMeta {
	if m != nil {
		return m.Tables
	}
	return nil
}

// TableMeta represents table metadata
type TableMeta struct {
	Schema  string        `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Table   string        `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Columns []*ColumnMeta `protobuf:"bytes,3,rep,name=columns,proto3" json:"columns,omitempty"`
}

func (m *TableMeta) Reset()      { *m = TableMeta{} }
func (*TableMeta) ProtoMessage() {}
func (*TableMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{7}
}
func (m *TableMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableMeta.Merge(m, src)
}
func (m *TableMeta) XXX_Size() int {
	return m.Size()
}
func (m *TableMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TableMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TableMeta proto.InternalMessageInfo

func (m *TableMeta) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *TableMeta) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TableMeta) GetColumns() []*ColumnMeta {
	if m != nil {
		return m.Columns
	}
	return nil
}

// ColumnMeta represents a column metadata
type ColumnMeta struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Comment string `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ColumnMeta) Reset()      { *m = ColumnMeta{} }
func (*ColumnMeta) ProtoMessage() {}
func (*ColumnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{8}
}
func (m *ColumnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnMeta.Merge(m, src)
}
func (m *ColumnMeta) XXX_Size() int {
	return m.Size()
}
func (m *ColumnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnMeta proto.InternalMessageInfo

func (m *ColumnMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColumnMeta) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ColumnMeta) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// GetSplitsRequest represents an request to get the splits for a table.
type GetSplitsRequest struct {
	Schema    string   `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Table     string   `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Columns   []string `protobuf:"bytes,3,rep,name=columns,proto3" json:"columns,omitempty"`
	Filters   []string `protobuf:"bytes,4,rep,name=filters,proto3" json:"filters,omitempty"`
	MaxSplits int32    `protobuf:"varint,5,opt,name=maxSplits,proto3" json:"maxSplits,omitempty"`
	NextToken []byte   `protobuf:"bytes,6,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetSplitsRequest) Reset()      { *m = GetSplitsRequest{} }
func (*GetSplitsRequest) ProtoMessage() {}
func (*GetSplitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{9}
}
func (m *GetSplitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSplitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSplitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSplitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSplitsRequest.Merge(m, src)
}
func (m *GetSplitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSplitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSplitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSplitsRequest proto.InternalMessageInfo

func (m *GetSplitsRequest) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *GetSplitsRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *GetSplitsRequest) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *GetSplitsRequest) GetFilters() []string {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *GetSplitsRequest) GetMaxSplits() int32 {
	if m != nil {
		return m.MaxSplits
	}
	return 0
}

func (m *GetSplitsRequest) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// GetSplitsResponse represents an response containing the splits for a table.
type GetSplitsResponse struct {
	Splits    []*Split `protobuf:"bytes,1,rep,name=splits,proto3" json:"splits,omitempty"`
	NextToken []byte   `protobuf:"bytes,2,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetSplitsResponse) Reset()      { *m = GetSplitsResponse{} }
func (*GetSplitsResponse) ProtoMessage() {}
func (*GetSplitsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{10}
}
func (m *GetSplitsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSplitsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSplitsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSplitsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSplitsResponse.Merge(m, src)
}
func (m *GetSplitsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSplitsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSplitsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSplitsResponse proto.InternalMessageInfo

func (m *GetSplitsResponse) GetSplits() []*Split {
	if m != nil {
		return m.Splits
	}
	return nil
}

func (m *GetSplitsResponse) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// Endpoint represents a host/port combination
type Endpoint struct {
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()      { *m = Endpoint{} }
func (*Endpoint) ProtoMessage() {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{11}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Endpoint) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Split represents the split information
type Split struct {
	SplitID []byte      `protobuf:"bytes,1,opt,name=splitID,proto3" json:"splitID,omitempty"`
	Hosts   []*Endpoint `protobuf:"bytes,2,rep,name=hosts,proto3" json:"hosts,omitempty"`
}

func (m *Split) Reset()      { *m = Split{} }
func (*Split) ProtoMessage() {}
func (*Split) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{12}
}
func (m *Split) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Split) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Split.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Split) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Split.Merge(m, src)
}
func (m *Split) XXX_Size() int {
	return m.Size()
}
func (m *Split) XXX_DiscardUnknown() {
	xxx_messageInfo_Split.DiscardUnknown(m)
}

var xxx_messageInfo_Split proto.InternalMessageInfo

func (m *Split) GetSplitID() []byte {
	if m != nil {
		return m.SplitID
	}
	return nil
}

func (m *Split) GetHosts() []*Endpoint {
	if m != nil {
		return m.Hosts
	}
	return nil
}

// GetRowsRequest represents an request to get the rows for a split.
type GetRowsRequest struct {
	SplitID   []byte   `protobuf:"bytes,1,opt,name=splitID,proto3" json:"splitID,omitempty"`
	Columns   []string `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns,omitempty"`
	MaxBytes  int64    `protobuf:"varint,3,opt,name=maxBytes,proto3" json:"maxBytes,omitempty"`
	NextToken []byte   `protobuf:"bytes,4,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetRowsRequest) Reset()      { *m = GetRowsRequest{} }
func (*GetRowsRequest) ProtoMessage() {}
func (*GetRowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{13}
}
func (m *GetRowsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRowsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRowsRequest.Merge(m, src)
}
func (m *GetRowsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRowsRequest proto.InternalMessageInfo

func (m *GetRowsRequest) GetSplitID() []byte {
	if m != nil {
		return m.SplitID
	}
	return nil
}

func (m *GetRowsRequest) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *GetRowsRequest) GetMaxBytes() int64 {
	if m != nil {
		return m.MaxBytes
	}
	return 0
}

func (m *GetRowsRequest) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// GetRowsResponse represents a response that returns the rows.
type GetRowsResponse struct {
	Columns   []*Column `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	RowCount  int32     `protobuf:"varint,2,opt,name=rowCount,proto3" json:"rowCount,omitempty"`
	NextToken []byte    `protobuf:"bytes,3,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetRowsResponse) Reset()      { *m = GetRowsResponse{} }
func (*GetRowsResponse) ProtoMessage() {}
func (*GetRowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{14}
}
func (m *GetRowsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRowsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRowsResponse.Merge(m, src)
}
func (m *GetRowsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRowsResponse proto.InternalMessageInfo

func (m *GetRowsResponse) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *GetRowsResponse) GetRowCount() int32 {
	if m != nil {
		return m.RowCount
	}
	return 0
}

func (m *GetRowsResponse) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// Column represents a column.
type Column struct {
	// Types that are valid to be assigned to Value:
	//	*Column_Int32
	//	*Column_Int64
	//	*Column_Float64
	//	*Column_String_
	//	*Column_Bool
	//	*Column_Time
	//	*Column_Json
	Value isColumn_Value `protobuf_oneof:"value"`
}

func (m *Column) Reset()      { *m = Column{} }
func (*Column) ProtoMessage() {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{15}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

type isColumn_Value interface {
	isColumn_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Column_Int32 struct {
	Int32 *ColumnOfInt32 `protobuf:"bytes,1,opt,name=int32,proto3,oneof" json:"int32,omitempty"`
}
type Column_Int64 struct {
	Int64 *ColumnOfInt64 `protobuf:"bytes,2,opt,name=int64,proto3,oneof" json:"int64,omitempty"`
}
type Column_Float64 struct {
	Float64 *ColumnOfFloat64 `protobuf:"bytes,3,opt,name=float64,proto3,oneof" json:"float64,omitempty"`
}
type Column_String_ struct {
	String_ *ColumnOfString `protobuf:"bytes,4,opt,name=string,proto3,oneof" json:"string,omitempty"`
}
type Column_Bool struct {
	Bool *ColumnOfBools `protobuf:"bytes,5,opt,name=bool,proto3,oneof" json:"bool,omitempty"`
}
type Column_Time struct {
	Time *ColumnOfInt64 `protobuf:"bytes,6,opt,name=time,proto3,oneof" json:"time,omitempty"`
}
type Column_Json struct {
	Json *ColumnOfString `protobuf:"bytes,7,opt,name=json,proto3,oneof" json:"json,omitempty"`
}

func (*Column_Int32) isColumn_Value()   {}
func (*Column_Int64) isColumn_Value()   {}
func (*Column_Float64) isColumn_Value() {}
func (*Column_String_) isColumn_Value() {}
func (*Column_Bool) isColumn_Value()    {}
func (*Column_Time) isColumn_Value()    {}
func (*Column_Json) isColumn_Value()    {}

func (m *Column) GetValue() isColumn_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Column) GetInt32() *ColumnOfInt32 {
	if x, ok := m.GetValue().(*Column_Int32); ok {
		return x.Int32
	}
	return nil
}

func (m *Column) GetInt64() *ColumnOfInt64 {
	if x, ok := m.GetValue().(*Column_Int64); ok {
		return x.Int64
	}
	return nil
}

func (m *Column) GetFloat64() *ColumnOfFloat64 {
	if x, ok := m.GetValue().(*Column_Float64); ok {
		return x.Float64
	}
	return nil
}

func (m *Column) GetString_() *ColumnOfString {
	if x, ok := m.GetValue().(*Column_String_); ok {
		return x.String_
	}
	return nil
}

func (m *Column) GetBool() *ColumnOfBools {
	if x, ok := m.GetValue().(*Column_Bool); ok {
		return x.Bool
	}
	return nil
}

func (m *Column) GetTime() *ColumnOfInt64 {
	if x, ok := m.GetValue().(*Column_Time); ok {
		return x.Time
	}
	return nil
}

func (m *Column) GetJson() *ColumnOfString {
	if x, ok := m.GetValue().(*Column_Json); ok {
		return x.Json
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Column) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Column_Int32)(nil),
		(*Column_Int64)(nil),
		(*Column_Float64)(nil),
		(*Column_String_)(nil),
		(*Column_Bool)(nil),
		(*Column_Time)(nil),
		(*Column_Json)(nil),
	}
}

// Column containing Int32 values
type ColumnOfInt32 struct {
	Nulls []bool  `protobuf:"varint,1,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	Ints  []int32 `protobuf:"varint,2,rep,packed,name=ints,proto3" json:"ints,omitempty"`
}

func (m *ColumnOfInt32) Reset()      { *m = ColumnOfInt32{} }
func (*ColumnOfInt32) ProtoMessage() {}
func (*ColumnOfInt32) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{16}
}
func (m *ColumnOfInt32) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOfInt32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnOfInt32.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnOfInt32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOfInt32.Merge(m, src)
}
func (m *ColumnOfInt32) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOfInt32) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOfInt32.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOfInt32 proto.InternalMessageInfo

func (m *ColumnOfInt32) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfInt32) GetInts() []int32 {
	if m != nil {
		return m.Ints
	}
	return nil
}

// Column containing Int64 values
type ColumnOfInt64 struct {
	Nulls []bool  `protobuf:"varint,1,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	Longs []int64 `protobuf:"varint,2,rep,packed,name=longs,proto3" json:"longs,omitempty"`
}

func (m *ColumnOfInt64) Reset()      { *m = ColumnOfInt64{} }
func (*ColumnOfInt64) ProtoMessage() {}
func (*ColumnOfInt64) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{17}
}
func (m *ColumnOfInt64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOfInt64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnOfInt64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnOfInt64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOfInt64.Merge(m, src)
}
func (m *ColumnOfInt64) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOfInt64) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOfInt64.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOfInt64 proto.InternalMessageInfo

func (m *ColumnOfInt64) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfInt64) GetLongs() []int64 {
	if m != nil {
		return m.Longs
	}
	return nil
}

// Column containing Float64 values
type ColumnOfFloat64 struct {
	Nulls   []bool    `protobuf:"varint,1,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	Doubles []float64 `protobuf:"fixed64,2,rep,packed,name=doubles,proto3" json:"doubles,omitempty"`
}

func (m *ColumnOfFloat64) Reset()      { *m = ColumnOfFloat64{} }
func (*ColumnOfFloat64) ProtoMessage() {}
func (*ColumnOfFloat64) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{18}
}
func (m *ColumnOfFloat64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOfFloat64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnOfFloat64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnOfFloat64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOfFloat64.Merge(m, src)
}
func (m *ColumnOfFloat64) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOfFloat64) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOfFloat64.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOfFloat64 proto.InternalMessageInfo

func (m *ColumnOfFloat64) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfFloat64) GetDoubles() []float64 {
	if m != nil {
		return m.Doubles
	}
	return nil
}

// Column containing Boolean values
type ColumnOfBools struct {
	Nulls []bool `protobuf:"varint,1,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	Bools []bool `protobuf:"varint,2,rep,packed,name=bools,proto3" json:"bools,omitempty"`
}

func (m *ColumnOfBools) Reset()      { *m = ColumnOfBools{} }
func (*ColumnOfBools) ProtoMessage() {}
func (*ColumnOfBools) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{19}
}
func (m *ColumnOfBools) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOfBools) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnOfBools.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnOfBools) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOfBools.Merge(m, src)
}
func (m *ColumnOfBools) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOfBools) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOfBools.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOfBools proto.InternalMessageInfo

func (m *ColumnOfBools) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfBools) GetBools() []bool {
	if m != nil {
		return m.Bools
	}
	return nil
}

// Column containing String values
type ColumnOfString struct {
	Nulls []bool  `protobuf:"varint,1,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	Sizes []int32 `protobuf:"varint,2,rep,packed,name=sizes,proto3" json:"sizes,omitempty"`
	Bytes []byte  `protobuf:"bytes,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
}

func (m *ColumnOfString) Reset()      { *m = ColumnOfString{} }
func (*ColumnOfString) ProtoMessage() {}
func (*ColumnOfString) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{20}
}
func (m *ColumnOfString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOfString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnOfString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnOfString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOfString.Merge(m, src)
}
func (m *ColumnOfString) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOfString) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOfString.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOfString proto.InternalMessageInfo

func (m *ColumnOfString) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfString) GetSizes() []int32 {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *ColumnOfString) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func init() {
	proto.RegisterType((*IngestRequest)(nil), "talaria.IngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "talaria.IngestResponse")
	proto.RegisterType((*Batch)(nil), "talaria.Batch")
	proto.RegisterMapType((map[uint32][]byte)(nil), "talaria.Batch.StringsEntry")
	proto.RegisterType((*Event)(nil), "talaria.Event")
	proto.RegisterMapType((map[uint32]*Value)(nil), "talaria.Event.ValueEntry")
	proto.RegisterType((*Value)(nil), "talaria.Value")
	proto.RegisterType((*DescribeRequest)(nil), "talaria.DescribeRequest")
	proto.RegisterType((*DescribeResponse)(nil), "talaria.DescribeResponse")
	proto.RegisterType((*TableMeta)(nil), "talaria.TableMeta")
	proto.RegisterType((*ColumnMeta)(nil), "talaria.ColumnMeta")
	proto.RegisterType((*GetSplitsRequest)(nil), "talaria.GetSplitsRequest")
	proto.RegisterType((*GetSplitsResponse)(nil), "talaria.GetSplitsResponse")
	proto.RegisterType((*Endpoint)(nil), "talaria.Endpoint")
	proto.RegisterType((*Split)(nil), "talaria.Split")
	proto.RegisterType((*GetRowsRequest)(nil), "talaria.GetRowsRequest")
	proto.RegisterType((*GetRowsResponse)(nil), "talaria.GetRowsResponse")
	proto.RegisterType((*Column)(nil), "talaria.Column")
	proto.RegisterType((*ColumnOfInt32)(nil), "talaria.ColumnOfInt32")
	proto.RegisterType((*ColumnOfInt64)(nil), "talaria.ColumnOfInt64")
	proto.RegisterType((*ColumnOfFloat64)(nil), "talaria.ColumnOfFloat64")
	proto.RegisterType((*ColumnOfBools)(nil), "talaria.ColumnOfBools")
	proto.RegisterType((*ColumnOfString)(nil), "talaria.ColumnOfString")
}

func init() { proto.RegisterFile("talaria.proto", fileDescriptor_8f344df92059c5ff) }

var fileDescriptor_8f344df92059c5ff = []byte{
	// 1065 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdf, 0x6e, 0x1b, 0xc5,
	0x17, 0xde, 0xb1, 0xbd, 0x6b, 0xfb, 0xe4, 0xff, 0xfc, 0xa2, 0x64, 0xeb, 0x1f, 0x5a, 0x45, 0x2b,
	0x14, 0x02, 0x6a, 0x8d, 0x70, 0x4d, 0x04, 0xad, 0x54, 0xa9, 0x6e, 0xd2, 0x3a, 0x48, 0x80, 0x98,
	0x56, 0x48, 0x5c, 0x6e, 0x9c, 0x49, 0xb2, 0x74, 0xbd, 0x63, 0x76, 0xc6, 0x69, 0x02, 0x12, 0x42,
	0x3c, 0x01, 0xcf, 0xc0, 0x15, 0x97, 0x5c, 0xf2, 0x08, 0x5c, 0xe6, 0xb2, 0x97, 0xc4, 0x11, 0x12,
	0x97, 0x7d, 0x04, 0x34, 0x33, 0x3b, 0xfb, 0x2f, 0x71, 0x25, 0xee, 0xf6, 0xfb, 0xce, 0x9c, 0xf3,
	0xcd, 0x9c, 0x33, 0xfb, 0xed, 0xc2, 0x92, 0x08, 0xa2, 0x20, 0x09, 0x83, 0xee, 0x24, 0x61, 0x82,
	0xe1, 0x66, 0x0a, 0xfd, 0x1f, 0x60, 0xe9, 0x20, 0x3e, 0xa1, 0x5c, 0x10, 0xfa, 0xdd, 0x94, 0x72,
	0x81, 0xb7, 0xc1, 0x3e, 0x0c, 0xc4, 0xe8, 0xd4, 0x45, 0x5b, 0x68, 0x67, 0xa1, 0xb7, 0xdc, 0x35,
	0x89, 0x03, 0xc9, 0x0e, 0x2d, 0xa2, 0xc3, 0x18, 0x43, 0x9d, 0x25, 0x23, 0xb7, 0xb6, 0x85, 0x76,
	0x16, 0x87, 0x16, 0x91, 0x40, 0x72, 0x23, 0x7e, 0xe6, 0xd6, 0x0d, 0x37, 0xe2, 0x67, 0x92, 0x9b,
	0x26, 0x91, 0xdb, 0xd8, 0x42, 0x3b, 0x6d, 0xc9, 0x4d, 0x93, 0x68, 0xe0, 0x40, 0xe3, 0x28, 0x10,
	0x81, 0xbf, 0x0a, 0xcb, 0x46, 0x9c, 0x4f, 0x58, 0xcc, 0xa9, 0xff, 0x2b, 0x02, 0x5b, 0x09, 0xe1,
	0x8f, 0xa1, 0xc9, 0x45, 0x12, 0xc6, 0x27, 0xdc, 0x45, 0x5b, 0xf5, 0x9d, 0x85, 0xde, 0xff, 0xcb,
	0x3b, 0xe9, 0x3e, 0xd7, 0xd1, 0xfd, 0x58, 0x24, 0x17, 0xc4, 0xac, 0xc5, 0xdb, 0xe0, 0xd0, 0x33,
	0x1a, 0x0b, 0xee, 0xd6, 0x54, 0x56, 0xbe, 0xff, 0x7d, 0x49, 0x93, 0x34, 0xda, 0x79, 0x00, 0x8b,
	0xc5, 0x02, 0x78, 0x15, 0xea, 0x2f, 0xe9, 0x85, 0x3a, 0xf4, 0x12, 0x91, 0x8f, 0x78, 0x1d, 0xec,
	0xb3, 0x20, 0x9a, 0x52, 0x7d, 0x44, 0xa2, 0xc1, 0x83, 0xda, 0x27, 0xc8, 0xff, 0x19, 0x81, 0xad,
	0xaa, 0xe1, 0x0f, 0xcd, 0x1a, 0xbd, 0xc5, 0x3b, 0x65, 0xb1, 0xee, 0xd7, 0x32, 0xa6, 0x37, 0xa8,
	0xd7, 0x75, 0x86, 0x00, 0x39, 0x79, 0x8b, 0xe8, 0xbb, 0x45, 0xd1, 0xe2, 0xee, 0x55, 0x56, 0x71,
	0x13, 0x7f, 0x20, 0xb0, 0x15, 0x89, 0x37, 0xc0, 0x0e, 0x63, 0x71, 0xbf, 0xa7, 0xea, 0xd8, 0x72,
	0x42, 0x0a, 0xa6, 0xfc, 0x6e, 0x5f, 0xd5, 0xaa, 0xa7, 0xfc, 0x6e, 0x1f, 0x77, 0xa0, 0x79, 0x1c,
	0xb1, 0x40, 0x46, 0xe4, 0xa4, 0xd0, 0xd0, 0x22, 0x86, 0xc0, 0x2e, 0x38, 0xba, 0x93, 0x6a, 0x60,
	0x4b, 0x43, 0x8b, 0xa4, 0x18, 0xaf, 0x43, 0xe3, 0x90, 0xb1, 0xc8, 0xb5, 0xb7, 0xd0, 0x4e, 0x6b,
	0x68, 0x11, 0x85, 0x24, 0x2b, 0xc2, 0x31, 0x75, 0x9d, 0x54, 0x42, 0x21, 0xc9, 0x7e, 0xcb, 0x59,
	0xec, 0x36, 0xd3, 0x1a, 0x0a, 0x0d, 0x9a, 0xe9, 0xd9, 0xfc, 0x35, 0x58, 0xd9, 0xa3, 0x7c, 0x94,
	0x84, 0x87, 0x34, 0xbd, 0x75, 0xfe, 0x23, 0x58, 0xcd, 0x29, 0x7d, 0x17, 0xf0, 0x07, 0xe0, 0x88,
	0xe0, 0x30, 0xa2, 0xe6, 0x02, 0xe0, 0xac, 0x19, 0x2f, 0x24, 0xfd, 0x39, 0x15, 0x01, 0x49, 0x57,
	0xf8, 0xa7, 0xd0, 0xce, 0x48, 0xbc, 0x01, 0x0e, 0x1f, 0x9d, 0xd2, 0x71, 0xa0, 0x3a, 0xd2, 0x26,
	0x29, 0x92, 0x13, 0x55, 0xcb, 0x55, 0x43, 0xda, 0x44, 0x03, 0x7c, 0x0f, 0x9a, 0x23, 0x16, 0x4d,
	0xc7, 0x31, 0x77, 0xeb, 0x4a, 0xe7, 0x7f, 0x99, 0xce, 0x13, 0xc5, 0x2b, 0x21, 0xb3, 0xc6, 0xff,
	0x02, 0x20, 0xa7, 0x31, 0x86, 0x46, 0x1c, 0x8c, 0x69, 0x2a, 0xa4, 0x9e, 0x25, 0x27, 0x2e, 0x26,
	0x46, 0x45, 0x3d, 0x63, 0x57, 0x8a, 0x8c, 0xc7, 0x34, 0x16, 0xaa, 0xe7, 0x6d, 0x62, 0xa0, 0xff,
	0x3b, 0x82, 0xd5, 0x67, 0x54, 0x3c, 0x9f, 0x44, 0xa1, 0xe0, 0xe6, 0x25, 0xfc, 0x6f, 0x27, 0x70,
	0xcb, 0x27, 0x68, 0x67, 0x9b, 0x95, 0x91, 0xe3, 0x30, 0x12, 0x34, 0xe1, 0x6e, 0x43, 0x47, 0x52,
	0x88, 0xdf, 0x81, 0xf6, 0x38, 0x38, 0xd7, 0xaa, 0x6a, 0xa6, 0x36, 0xc9, 0x09, 0x19, 0x8d, 0xe9,
	0xb9, 0x78, 0xc1, 0x5e, 0xd2, 0x58, 0xcd, 0x76, 0x91, 0xe4, 0x84, 0xff, 0x0d, 0xac, 0x15, 0x76,
	0x9c, 0x4e, 0x6b, 0x1b, 0x1c, 0xae, 0xab, 0xa1, 0xca, 0x8b, 0xa7, 0x16, 0x92, 0x34, 0x5a, 0x2e,
	0x5d, 0xab, 0x96, 0xee, 0x41, 0x6b, 0x3f, 0x3e, 0x9a, 0xb0, 0x30, 0x16, 0xb2, 0x8f, 0xa7, 0x8c,
	0x0b, 0xd3, 0x5b, 0xf9, 0x2c, 0xb9, 0x09, 0x4b, 0x84, 0x4a, 0xb4, 0x89, 0x7a, 0xf6, 0x3f, 0x03,
	0x5b, 0x49, 0xc8, 0xd3, 0x2a, 0x91, 0x83, 0x3d, 0x95, 0xb3, 0x48, 0x0c, 0xc4, 0xef, 0x81, 0x2d,
	0xd3, 0x8d, 0x29, 0xac, 0xe5, 0xef, 0x69, 0x2a, 0x46, 0x74, 0xdc, 0xff, 0x11, 0x96, 0x9f, 0x51,
	0x41, 0xd8, 0xab, 0x6c, 0x14, 0xf3, 0x8b, 0x16, 0xda, 0x5e, 0x2b, 0xb7, 0xbd, 0x03, 0xad, 0x71,
	0x70, 0x3e, 0xb8, 0x10, 0x94, 0xab, 0x71, 0xd7, 0x49, 0x86, 0xcb, 0xe7, 0x6f, 0x54, 0xcf, 0x7f,
	0x06, 0x2b, 0x99, 0x7e, 0xda, 0xd8, 0xf7, 0x73, 0x19, 0xdd, 0xd9, 0x95, 0xca, 0xfd, 0x2c, 0xe9,
	0x26, 0xec, 0xd5, 0x13, 0x36, 0x8d, 0x4d, 0x87, 0x32, 0x5c, 0xd6, 0xad, 0x57, 0x75, 0xff, 0xae,
	0x81, 0xa3, 0xab, 0xe1, 0x6e, 0xd1, 0x4e, 0x16, 0x7a, 0x1b, 0x15, 0xb5, 0x2f, 0x8f, 0x0f, 0x64,
	0x34, 0xb7, 0x99, 0x6e, 0xd1, 0x66, 0xe6, 0xac, 0xdf, 0xed, 0xe7, 0xf6, 0xd3, 0x2f, 0xdb, 0xcf,
	0x42, 0xcf, 0xbd, 0x91, 0xf1, 0x54, 0xc7, 0x8b, 0xc6, 0xf4, 0x51, 0xc9, 0x98, 0x16, 0x7a, 0x9b,
	0x37, 0x92, 0xb4, 0x9d, 0x17, 0x1c, 0xeb, 0x6e, 0xc1, 0xb1, 0x6e, 0xdb, 0xd7, 0x80, 0xb1, 0x88,
	0x67, 0x4e, 0x76, 0xb7, 0xe0, 0x64, 0x6f, 0x3b, 0x85, 0x76, 0xb8, 0x7b, 0x05, 0x87, 0x7b, 0xeb,
	0x66, 0x2a, 0xd6, 0xf7, 0x29, 0x2c, 0x95, 0xda, 0x28, 0xdf, 0xe8, 0x78, 0x1a, 0x45, 0x7a, 0xb6,
	0x2d, 0xa2, 0x81, 0xbc, 0xe6, 0xa1, 0xf9, 0x86, 0xd9, 0x44, 0x3d, 0xfb, 0x0f, 0x4b, 0xa9, 0xbb,
	0xfd, 0x39, 0xa9, 0xeb, 0x60, 0x47, 0x4c, 0x7e, 0x35, 0x65, 0x6e, 0x9d, 0x68, 0xe0, 0x3f, 0x86,
	0x95, 0x4a, 0x73, 0xe7, 0xa4, 0xbb, 0xd0, 0x3c, 0x62, 0x53, 0xe5, 0xba, 0xb2, 0x00, 0x22, 0x06,
	0x16, 0xf5, 0x55, 0xe7, 0xe6, 0xeb, 0xcb, 0x7e, 0xea, 0xf4, 0x16, 0xd1, 0xc0, 0x27, 0xb0, 0x5c,
	0x6e, 0xcd, 0xfc, 0x6c, 0x1e, 0x7e, 0x4f, 0xcd, 0xc9, 0x35, 0x50, 0x35, 0xb3, 0x97, 0x69, 0x91,
	0x68, 0xd0, 0x7b, 0x0a, 0xcd, 0x83, 0xf8, 0x24, 0xa1, 0x9c, 0xe3, 0x87, 0xe0, 0xe8, 0x1f, 0x09,
	0x9c, 0x0f, 0xae, 0xf4, 0x5b, 0xd3, 0xd9, 0xbc, 0xc1, 0xa7, 0x7f, 0x1c, 0x56, 0xef, 0x12, 0x81,
	0xfd, 0xd5, 0x94, 0x26, 0x17, 0xf8, 0x31, 0xb4, 0xcc, 0x57, 0x08, 0xe7, 0xb7, 0xb2, 0xf2, 0xad,
	0xea, 0xdc, 0xb9, 0x25, 0x62, 0x8a, 0xe1, 0x3d, 0x68, 0x67, 0xde, 0x88, 0xf3, 0x95, 0x55, 0x87,
	0xef, 0x74, 0x6e, 0x0b, 0x65, 0x55, 0x1e, 0x41, 0x33, 0xb5, 0x01, 0xbc, 0x59, 0x5c, 0x58, 0x30,
	0xa6, 0x8e, 0x7b, 0x33, 0x60, 0xf2, 0x07, 0xfd, 0xcb, 0x2b, 0xcf, 0x7a, 0x7d, 0xe5, 0x59, 0x6f,
	0xae, 0x3c, 0xf4, 0xd3, 0xcc, 0x43, 0xbf, 0xcd, 0x3c, 0xf4, 0xe7, 0xcc, 0x43, 0x97, 0x33, 0x0f,
	0xfd, 0x35, 0xf3, 0xd0, 0x3f, 0x33, 0xcf, 0x7a, 0x33, 0xf3, 0xd0, 0x2f, 0xd7, 0x9e, 0x75, 0x79,
	0xed, 0x59, 0xaf, 0xaf, 0x3d, 0xeb, 0xd0, 0x51, 0xff, 0x86, 0xf7, 0xff, 0x0d, 0x00, 0x00, 0xff,
	0xff, 0x27, 0xd3, 0x68, 0xdd, 0x2c, 0x0a, 0x00, 0x00,
}

func (this *IngestRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestRequest)
	if !ok {
		that2, ok := that.(IngestRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Data == nil {
		if this.Data != nil {
			return false
		}
	} else if this.Data == nil {
		return false
	} else if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *IngestRequest_Batch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestRequest_Batch)
	if !ok {
		that2, ok := that.(IngestRequest_Batch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Batch.Equal(that1.Batch) {
		return false
	}
	return true
}
func (this *IngestRequest_Orc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestRequest_Orc)
	if !ok {
		that2, ok := that.(IngestRequest_Orc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Orc, that1.Orc) {
		return false
	}
	return true
}
func (this *IngestRequest_Csv) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestRequest_Csv)
	if !ok {
		that2, ok := that.(IngestRequest_Csv)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Csv, that1.Csv) {
		return false
	}
	return true
}
func (this *IngestRequest_Url) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestRequest_Url)
	if !ok {
		that2, ok := that.(IngestRequest_Url)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *IngestResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestResponse)
	if !ok {
		that2, ok := that.(IngestResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Batch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Batch)
	if !ok {
		that2, ok := that.(Batch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Strings) != len(that1.Strings) {
		return false
	}
	for i := range this.Strings {
		if !bytes.Equal(this.Strings[i], that1.Strings[i]) {
			return false
		}
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Value_Int32) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Int32)
	if !ok {
		that2, ok := that.(Value_Int32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int32 != that1.Int32 {
		return false
	}
	return true
}
func (this *Value_Int64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Int64)
	if !ok {
		that2, ok := that.(Value_Int64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int64 != that1.Int64 {
		return false
	}
	return true
}
func (this *Value_Float64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Float64)
	if !ok {
		that2, ok := that.(Value_Float64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Float64 != that1.Float64 {
		return false
	}
	return true
}
func (this *Value_String_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_String_)
	if !ok {
		that2, ok := that.(Value_String_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.String_ != that1.String_ {
		return false
	}
	return true
}
func (this *Value_Bool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Bool)
	if !ok {
		that2, ok := that.(Value_Bool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bool != that1.Bool {
		return false
	}
	return true
}
func (this *Value_Time) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Time)
	if !ok {
		that2, ok := that.(Value_Time)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *Value_Json) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Json)
	if !ok {
		that2, ok := that.(Value_Json)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Json != that1.Json {
		return false
	}
	return true
}
func (this *DescribeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DescribeRequest)
	if !ok {
		that2, ok := that.(DescribeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DescribeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DescribeResponse)
	if !ok {
		that2, ok := that.(DescribeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Tables) != len(that1.Tables) {
		return false
	}
	for i := range this.Tables {
		if !this.Tables[i].Equal(that1.Tables[i]) {
			return false
		}
	}
	return true
}
func (this *TableMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableMeta)
	if !ok {
		that2, ok := that.(TableMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.Table != that1.Table {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *ColumnMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnMeta)
	if !ok {
		that2, ok := that.(ColumnMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *GetSplitsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSplitsRequest)
	if !ok {
		that2, ok := that.(GetSplitsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.Table != that1.Table {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if this.Columns[i] != that1.Columns[i] {
			return false
		}
	}
	if len(this.Filters) != len(that1.Filters) {
		return false
	}
	for i := range this.Filters {
		if this.Filters[i] != that1.Filters[i] {
			return false
		}
	}
	if this.MaxSplits != that1.MaxSplits {
		return false
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *GetSplitsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSplitsResponse)
	if !ok {
		that2, ok := that.(GetSplitsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Splits) != len(that1.Splits) {
		return false
	}
	for i := range this.Splits {
		if !this.Splits[i].Equal(that1.Splits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *Endpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Endpoint)
	if !ok {
		that2, ok := that.(Endpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *Split) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Split)
	if !ok {
		that2, ok := that.(Split)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SplitID, that1.SplitID) {
		return false
	}
	if len(this.Hosts) != len(that1.Hosts) {
		return false
	}
	for i := range this.Hosts {
		if !this.Hosts[i].Equal(that1.Hosts[i]) {
			return false
		}
	}
	return true
}
func (this *GetRowsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetRowsRequest)
	if !ok {
		that2, ok := that.(GetRowsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SplitID, that1.SplitID) {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if this.Columns[i] != that1.Columns[i] {
			return false
		}
	}
	if this.MaxBytes != that1.MaxBytes {
		return false
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *GetRowsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetRowsResponse)
	if !ok {
		that2, ok := that.(GetRowsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	if this.RowCount != that1.RowCount {
		return false
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Column_Int32) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_Int32)
	if !ok {
		that2, ok := that.(Column_Int32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Int32.Equal(that1.Int32) {
		return false
	}
	return true
}
func (this *Column_Int64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_Int64)
	if !ok {
		that2, ok := that.(Column_Int64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Int64.Equal(that1.Int64) {
		return false
	}
	return true
}
func (this *Column_Float64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_Float64)
	if !ok {
		that2, ok := that.(Column_Float64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Float64.Equal(that1.Float64) {
		return false
	}
	return true
}
func (this *Column_String_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_String_)
	if !ok {
		that2, ok := that.(Column_String_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.String_.Equal(that1.String_) {
		return false
	}
	return true
}
func (this *Column_Bool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_Bool)
	if !ok {
		that2, ok := that.(Column_Bool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Bool.Equal(that1.Bool) {
		return false
	}
	return true
}
func (this *Column_Time) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_Time)
	if !ok {
		that2, ok := that.(Column_Time)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Time.Equal(that1.Time) {
		return false
	}
	return true
}
func (this *Column_Json) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column_Json)
	if !ok {
		that2, ok := that.(Column_Json)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Json.Equal(that1.Json) {
		return false
	}
	return true
}
func (this *ColumnOfInt32) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOfInt32)
	if !ok {
		that2, ok := that.(ColumnOfInt32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Ints) != len(that1.Ints) {
		return false
	}
	for i := range this.Ints {
		if this.Ints[i] != that1.Ints[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfInt64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOfInt64)
	if !ok {
		that2, ok := that.(ColumnOfInt64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Longs) != len(that1.Longs) {
		return false
	}
	for i := range this.Longs {
		if this.Longs[i] != that1.Longs[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfFloat64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOfFloat64)
	if !ok {
		that2, ok := that.(ColumnOfFloat64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Doubles) != len(that1.Doubles) {
		return false
	}
	for i := range this.Doubles {
		if this.Doubles[i] != that1.Doubles[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfBools) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOfBools)
	if !ok {
		that2, ok := that.(ColumnOfBools)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Bools) != len(that1.Bools) {
		return false
	}
	for i := range this.Bools {
		if this.Bools[i] != that1.Bools[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfString) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOfString)
	if !ok {
		that2, ok := that.(ColumnOfString)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Sizes) != len(that1.Sizes) {
		return false
	}
	for i := range this.Sizes {
		if this.Sizes[i] != that1.Sizes[i] {
			return false
		}
	}
	if !bytes.Equal(this.Bytes, that1.Bytes) {
		return false
	}
	return true
}
func (this *IngestRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&talaria.IngestRequest{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IngestRequest_Batch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.IngestRequest_Batch{` +
		`Batch:` + fmt.Sprintf("%#v", this.Batch) + `}`}, ", ")
	return s
}
func (this *IngestRequest_Orc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.IngestRequest_Orc{` +
		`Orc:` + fmt.Sprintf("%#v", this.Orc) + `}`}, ", ")
	return s
}
func (this *IngestRequest_Csv) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.IngestRequest_Csv{` +
		`Csv:` + fmt.Sprintf("%#v", this.Csv) + `}`}, ", ")
	return s
}
func (this *IngestRequest_Url) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.IngestRequest_Url{` +
		`Url:` + fmt.Sprintf("%#v", this.Url) + `}`}, ", ")
	return s
}
func (this *IngestResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&talaria.IngestResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Batch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Batch{")
	keysForStrings := make([]uint32, 0, len(this.Strings))
	for k, _ := range this.Strings {
		keysForStrings = append(keysForStrings, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForStrings)
	mapStringForStrings := "map[uint32][]byte{"
	for _, k := range keysForStrings {
		mapStringForStrings += fmt.Sprintf("%#v: %#v,", k, this.Strings[k])
	}
	mapStringForStrings += "}"
	if this.Strings != nil {
		s = append(s, "Strings: "+mapStringForStrings+",\n")
	}
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&talaria.Event{")
	keysForValue := make([]uint32, 0, len(this.Value))
	for k, _ := range this.Value {
		keysForValue = append(keysForValue, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForValue)
	mapStringForValue := "map[uint32]*Value{"
	for _, k := range keysForValue {
		mapStringForValue += fmt.Sprintf("%#v: %#v,", k, this.Value[k])
	}
	mapStringForValue += "}"
	if this.Value != nil {
		s = append(s, "Value: "+mapStringForValue+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&talaria.Value{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Int32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Int32{` +
		`Int32:` + fmt.Sprintf("%#v", this.Int32) + `}`}, ", ")
	return s
}
func (this *Value_Int64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Int64{` +
		`Int64:` + fmt.Sprintf("%#v", this.Int64) + `}`}, ", ")
	return s
}
func (this *Value_Float64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Float64{` +
		`Float64:` + fmt.Sprintf("%#v", this.Float64) + `}`}, ", ")
	return s
}
func (this *Value_String_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_String_{` +
		`String_:` + fmt.Sprintf("%#v", this.String_) + `}`}, ", ")
	return s
}
func (this *Value_Bool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Bool{` +
		`Bool:` + fmt.Sprintf("%#v", this.Bool) + `}`}, ", ")
	return s
}
func (this *Value_Time) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Time{` +
		`Time:` + fmt.Sprintf("%#v", this.Time) + `}`}, ", ")
	return s
}
func (this *Value_Json) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Json{` +
		`Json:` + fmt.Sprintf("%#v", this.Json) + `}`}, ", ")
	return s
}
func (this *DescribeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&talaria.DescribeRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DescribeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&talaria.DescribeResponse{")
	if this.Tables != nil {
		s = append(s, "Tables: "+fmt.Sprintf("%#v", this.Tables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TableMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.TableMeta{")
	s = append(s, "Schema: "+fmt.Sprintf("%#v", this.Schema)+",\n")
	s = append(s, "Table: "+fmt.Sprintf("%#v", this.Table)+",\n")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.ColumnMeta{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Comment: "+fmt.Sprintf("%#v", this.Comment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSplitsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&talaria.GetSplitsRequest{")
	s = append(s, "Schema: "+fmt.Sprintf("%#v", this.Schema)+",\n")
	s = append(s, "Table: "+fmt.Sprintf("%#v", this.Table)+",\n")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "Filters: "+fmt.Sprintf("%#v", this.Filters)+",\n")
	s = append(s, "MaxSplits: "+fmt.Sprintf("%#v", this.MaxSplits)+",\n")
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSplitsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.GetSplitsResponse{")
	if this.Splits != nil {
		s = append(s, "Splits: "+fmt.Sprintf("%#v", this.Splits)+",\n")
	}
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Endpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Endpoint{")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Split) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Split{")
	s = append(s, "SplitID: "+fmt.Sprintf("%#v", this.SplitID)+",\n")
	if this.Hosts != nil {
		s = append(s, "Hosts: "+fmt.Sprintf("%#v", this.Hosts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetRowsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&talaria.GetRowsRequest{")
	s = append(s, "SplitID: "+fmt.Sprintf("%#v", this.SplitID)+",\n")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "MaxBytes: "+fmt.Sprintf("%#v", this.MaxBytes)+",\n")
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetRowsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.GetRowsResponse{")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "RowCount: "+fmt.Sprintf("%#v", this.RowCount)+",\n")
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Column) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&talaria.Column{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Column_Int32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Int32{` +
		`Int32:` + fmt.Sprintf("%#v", this.Int32) + `}`}, ", ")
	return s
}
func (this *Column_Int64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Int64{` +
		`Int64:` + fmt.Sprintf("%#v", this.Int64) + `}`}, ", ")
	return s
}
func (this *Column_Float64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Float64{` +
		`Float64:` + fmt.Sprintf("%#v", this.Float64) + `}`}, ", ")
	return s
}
func (this *Column_String_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_String_{` +
		`String_:` + fmt.Sprintf("%#v", this.String_) + `}`}, ", ")
	return s
}
func (this *Column_Bool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Bool{` +
		`Bool:` + fmt.Sprintf("%#v", this.Bool) + `}`}, ", ")
	return s
}
func (this *Column_Time) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Time{` +
		`Time:` + fmt.Sprintf("%#v", this.Time) + `}`}, ", ")
	return s
}
func (this *Column_Json) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Json{` +
		`Json:` + fmt.Sprintf("%#v", this.Json) + `}`}, ", ")
	return s
}
func (this *ColumnOfInt32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfInt32{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Ints: "+fmt.Sprintf("%#v", this.Ints)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfInt64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfInt64{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Longs: "+fmt.Sprintf("%#v", this.Longs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfFloat64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfFloat64{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Doubles: "+fmt.Sprintf("%#v", this.Doubles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfBools) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfBools{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Bools: "+fmt.Sprintf("%#v", this.Bools)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfString) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.ColumnOfString{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Sizes: "+fmt.Sprintf("%#v", this.Sizes)+",\n")
	s = append(s, "Bytes: "+fmt.Sprintf("%#v", this.Bytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTalaria(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IngressClient is the client API for Ingress service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IngressClient interface {
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
}

type ingressClient struct {
	cc *grpc.ClientConn
}

func NewIngressClient(cc *grpc.ClientConn) IngressClient {
	return &ingressClient{cc}
}

func (c *ingressClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/talaria.Ingress/Ingest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IngressServer is the server API for Ingress service.
type IngressServer interface {
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
}

// UnimplementedIngressServer can be embedded to have forward compatible implementations.
type UnimplementedIngressServer struct {
}

func (*UnimplementedIngressServer) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ingest not implemented")
}

func RegisterIngressServer(s *grpc.Server, srv IngressServer) {
	s.RegisterService(&_Ingress_serviceDesc, srv)
}

func _Ingress_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IngressServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Ingress/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IngressServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ingress_serviceDesc = grpc.ServiceDesc{
	ServiceName: "talaria.Ingress",
	HandlerType: (*IngressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ingest",
			Handler:    _Ingress_Ingest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talaria.proto",
}

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Describe returns the list of schema/table combinations and the metadata
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	// GetSplits returns the list of splits for a particular table/filter combination
	GetSplits(ctx context.Context, in *GetSplitsRequest, opts ...grpc.CallOption) (*GetSplitsResponse, error)
	// GetRows returns the rows for a particular split
	GetRows(ctx context.Context, in *GetRowsRequest, opts ...grpc.CallOption) (*GetRowsResponse, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	out := new(DescribeResponse)
	err := c.cc.Invoke(ctx, "/talaria.Query/Describe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetSplits(ctx context.Context, in *GetSplitsRequest, opts ...grpc.CallOption) (*GetSplitsResponse, error) {
	out := new(GetSplitsResponse)
	err := c.cc.Invoke(ctx, "/talaria.Query/GetSplits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetRows(ctx context.Context, in *GetRowsRequest, opts ...grpc.CallOption) (*GetRowsResponse, error) {
	out := new(GetRowsResponse)
	err := c.cc.Invoke(ctx, "/talaria.Query/GetRows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Describe returns the list of schema/table combinations and the metadata
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	// GetSplits returns the list of splits for a particular table/filter combination
	GetSplits(context.Context, *GetSplitsRequest) (*GetSplitsResponse, error)
	// GetRows returns the rows for a particular split
	GetRows(context.Context, *GetRowsRequest) (*GetRowsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Describe(ctx context.Context, req *DescribeRequest) (*DescribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (*UnimplementedQueryServer) GetSplits(ctx context.Context, req *GetSplitsRequest) (*GetSplitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSplits not implemented")
}
func (*UnimplementedQueryServer) GetRows(ctx context.Context, req *GetRowsRequest) (*GetRowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRows not implemented")
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Query/Describe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetSplits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSplitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetSplits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Query/GetSplits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetSplits(ctx, req.(*GetSplitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetRows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetRows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Query/GetRows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetRows(ctx, req.(*GetRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "talaria.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Describe",
			Handler:    _Query_Describe_Handler,
		},
		{
			MethodName: "GetSplits",
			Handler:    _Query_GetSplits_Handler,
		},
		{
			MethodName: "GetRows",
			Handler:    _Query_GetRows_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talaria.proto",
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IngestRequest_Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest_Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IngestRequest_Orc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest_Orc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Orc != nil {
		i -= len(m.Orc)
		copy(dAtA[i:], m.Orc)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Orc)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IngestRequest_Csv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest_Csv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Csv != nil {
		i -= len(m.Csv)
		copy(dAtA[i:], m.Csv)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Csv)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IngestRequest_Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest_Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintTalaria(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Strings) > 0 {
		for k := range m.Strings {
			v := m.Strings[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintTalaria(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTalaria(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTalaria(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k := range m.Value {
			v := m.Value[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTalaria(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTalaria(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTalaria(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_Int32) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int32) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Int32))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Value_Int64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Int64))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Value_Float64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Float64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float64))))
	i--
	dAtA[i] = 0x19
	return len(dAtA) - i, nil
}
func (m *Value_String_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_String_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.String_))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Value_Bool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Bool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Value_Time) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Time) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Value_Json) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Json) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Json))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *DescribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DescribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSplitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSplitsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSplitsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextToken) > 0 {
		i -= len(m.NextToken)
		copy(dAtA[i:], m.NextToken)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxSplits != 0 {
		i = encodeVarintTalaria(dAtA, i, uint64(m.MaxSplits))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Filters[iNdEx])
			copy(dAtA[i:], m.Filters[iNdEx])
			i = encodeVarintTalaria(dAtA, i, uint64(len(m.Filters[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintTalaria(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSplitsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSplitsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSplitsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextToken) > 0 {
		i -= len(m.NextToken)
		copy(dAtA[i:], m.NextToken)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Splits) > 0 {
		for iNdEx := len(m.Splits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Splits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintTalaria(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Split) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Split) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Split) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hosts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SplitID) > 0 {
		i -= len(m.SplitID)
		copy(dAtA[i:], m.SplitID)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.SplitID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRowsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRowsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextToken) > 0 {
		i -= len(m.NextToken)
		copy(dAtA[i:], m.NextToken)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i--
		dAtA[i] = 0x22
	}
	if m.MaxBytes != 0 {
		i = encodeVarintTalaria(dAtA, i, uint64(m.MaxBytes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintTalaria(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SplitID) > 0 {
		i -= len(m.SplitID)
		copy(dAtA[i:], m.SplitID)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.SplitID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRowsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRowsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextToken) > 0 {
		i -= len(m.NextToken)
		copy(dAtA[i:], m.NextToken)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RowCount != 0 {
		i = encodeVarintTalaria(dAtA, i, uint64(m.RowCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Column_Int32) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_Int32) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int32 != nil {
		{
			size, err := m.Int32.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Column_Int64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_Int64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int64 != nil {
		{
			size, err := m.Int64.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Column_Float64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_Float64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Float64 != nil {
		{
			size, err := m.Float64.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Column_String_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_String_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.String_ != nil {
		{
			size, err := m.String_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Column_Bool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_Bool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bool != nil {
		{
			size, err := m.Bool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Column_Time) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_Time) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Column_Json) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_Json) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Json != nil {
		{
			size, err := m.Json.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ColumnOfInt32) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfInt32) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOfInt32) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ints) > 0 {
		dAtA11 := make([]byte, len(m.Ints)*10)
		var j10 int
		for _, num1 := range m.Ints {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTalaria(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOfInt64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfInt64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOfInt64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Longs) > 0 {
		dAtA13 := make([]byte, len(m.Longs)*10)
		var j12 int
		for _, num1 := range m.Longs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintTalaria(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOfFloat64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfFloat64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOfFloat64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Doubles) > 0 {
		for iNdEx := len(m.Doubles) - 1; iNdEx >= 0; iNdEx-- {
			f14 := math.Float64bits(float64(m.Doubles[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f14))
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Doubles)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOfBools) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfBools) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOfBools) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bools) > 0 {
		for iNdEx := len(m.Bools) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Bools[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Bools)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOfString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOfString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bytes) > 0 {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sizes) > 0 {
		dAtA16 := make([]byte, len(m.Sizes)*10)
		var j15 int
		for _, num1 := range m.Sizes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintTalaria(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTalaria(dAtA []byte, offset int, v uint64) int {
	offset -= sovTalaria(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IngestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *IngestRequest_Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *IngestRequest_Orc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Orc != nil {
		l = len(m.Orc)
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *IngestRequest_Csv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Csv != nil {
		l = len(m.Csv)
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *IngestRequest_Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovTalaria(uint64(l))
	return n
}
func (m *IngestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTalaria(uint64(len(v)))
			}
			mapEntrySize := 1 + sovTalaria(uint64(k)) + l
			n += mapEntrySize + 1 + sovTalaria(uint64(mapEntrySize))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTalaria(uint64(l))
			}
			mapEntrySize := 1 + sovTalaria(uint64(k)) + l
			n += mapEntrySize + 1 + sovTalaria(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Value_Int32) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Int32))
	return n
}
func (m *Value_Int64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Int64))
	return n
}
func (m *Value_Float64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_String_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.String_))
	return n
}
func (m *Value_Bool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_Time) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Time))
	return n
}
func (m *Value_Json) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Json))
	return n
}
func (m *DescribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DescribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *TableMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *ColumnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *GetSplitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if len(m.Filters) > 0 {
		for _, s := range m.Filters {
			l = len(s)
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if m.MaxSplits != 0 {
		n += 1 + sovTalaria(uint64(m.MaxSplits))
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *GetSplitsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Splits) > 0 {
		for _, e := range m.Splits {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTalaria(uint64(m.Port))
	}
	return n
}

func (m *Split) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SplitID)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Hosts) > 0 {
		for _, e := range m.Hosts {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *GetRowsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SplitID)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if m.MaxBytes != 0 {
		n += 1 + sovTalaria(uint64(m.MaxBytes))
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *GetRowsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if m.RowCount != 0 {
		n += 1 + sovTalaria(uint64(m.RowCount))
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Column_Int32) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int32 != nil {
		l = m.Int32.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Int64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int64 != nil {
		l = m.Int64.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Float64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Float64 != nil {
		l = m.Float64.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_String_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.String_ != nil {
		l = m.String_.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Bool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bool != nil {
		l = m.Bool.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Time) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Json) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Json != nil {
		l = m.Json.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *ColumnOfInt32) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Ints) > 0 {
		l = 0
		for _, e := range m.Ints {
			l += sovTalaria(uint64(e))
		}
		n += 1 + sovTalaria(uint64(l)) + l
	}
	return n
}

func (m *ColumnOfInt64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Longs) > 0 {
		l = 0
		for _, e := range m.Longs {
			l += sovTalaria(uint64(e))
		}
		n += 1 + sovTalaria(uint64(l)) + l
	}
	return n
}

func (m *ColumnOfFloat64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Doubles) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Doubles)*8)) + len(m.Doubles)*8
	}
	return n
}

func (m *ColumnOfBools) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Bools) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Bools))) + len(m.Bools)*1
	}
	return n
}

func (m *ColumnOfString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovTalaria(uint64(e))
		}
		n += 1 + sovTalaria(uint64(l)) + l
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func sovTalaria(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTalaria(x uint64) (n int) {
	return sovTalaria(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *IngestRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest_Batch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest_Batch{`,
		`Batch:` + strings.Replace(fmt.Sprintf("%v", this.Batch), "Batch", "Batch", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest_Orc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest_Orc{`,
		`Orc:` + fmt.Sprintf("%v", this.Orc) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest_Csv) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest_Csv{`,
		`Csv:` + fmt.Sprintf("%v", this.Csv) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest_Url) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest_Url{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestResponse{`,
		`}`,
	}, "")
	return s
}
func (this *Batch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEvents := "[]*Event{"
	for _, f := range this.Events {
		repeatedStringForEvents += strings.Replace(f.String(), "Event", "Event", 1) + ","
	}
	repeatedStringForEvents += "}"
	keysForStrings := make([]uint32, 0, len(this.Strings))
	for k, _ := range this.Strings {
		keysForStrings = append(keysForStrings, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForStrings)
	mapStringForStrings := "map[uint32][]byte{"
	for _, k := range keysForStrings {
		mapStringForStrings += fmt.Sprintf("%v: %v,", k, this.Strings[k])
	}
	mapStringForStrings += "}"
	s := strings.Join([]string{`&Batch{`,
		`Strings:` + mapStringForStrings + `,`,
		`Events:` + repeatedStringForEvents + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	keysForValue := make([]uint32, 0, len(this.Value))
	for k, _ := range this.Value {
		keysForValue = append(keysForValue, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForValue)
	mapStringForValue := "map[uint32]*Value{"
	for _, k := range keysForValue {
		mapStringForValue += fmt.Sprintf("%v: %v,", k, this.Value[k])
	}
	mapStringForValue += "}"
	s := strings.Join([]string{`&Event{`,
		`Value:` + mapStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int32{`,
		`Int32:` + fmt.Sprintf("%v", this.Int32) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int64{`,
		`Int64:` + fmt.Sprintf("%v", this.Int64) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Float64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Float64{`,
		`Float64:` + fmt.Sprintf("%v", this.Float64) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_String_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_String_{`,
		`String_:` + fmt.Sprintf("%v", this.String_) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Bool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Bool{`,
		`Bool:` + fmt.Sprintf("%v", this.Bool) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Time) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Time{`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Json) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Json{`,
		`Json:` + fmt.Sprintf("%v", this.Json) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DescribeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DescribeRequest{`,
		`}`,
	}, "")
	return s
}
func (this *DescribeResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTables := "[]*TableMeta{"
	for _, f := range this.Tables {
		repeatedStringForTables += strings.Replace(f.String(), "TableMeta", "TableMeta", 1) + ","
	}
	repeatedStringForTables += "}"
	s := strings.Join([]string{`&DescribeResponse{`,
		`Tables:` + repeatedStringForTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *TableMeta) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]*ColumnMeta{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(f.String(), "ColumnMeta", "ColumnMeta", 1) + ","
	}
	repeatedStringForColumns += "}"
	s := strings.Join([]string{`&TableMeta{`,
		`Schema:` + fmt.Sprintf("%v", this.Schema) + `,`,
		`Table:` + fmt.Sprintf("%v", this.Table) + `,`,
		`Columns:` + repeatedStringForColumns + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnMeta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnMeta{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Comment:` + fmt.Sprintf("%v", this.Comment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSplitsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSplitsRequest{`,
		`Schema:` + fmt.Sprintf("%v", this.Schema) + `,`,
		`Table:` + fmt.Sprintf("%v", this.Table) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Filters:` + fmt.Sprintf("%v", this.Filters) + `,`,
		`MaxSplits:` + fmt.Sprintf("%v", this.MaxSplits) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSplitsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSplits := "[]*Split{"
	for _, f := range this.Splits {
		repeatedStringForSplits += strings.Replace(f.String(), "Split", "Split", 1) + ","
	}
	repeatedStringForSplits += "}"
	s := strings.Join([]string{`&GetSplitsResponse{`,
		`Splits:` + repeatedStringForSplits + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Endpoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Endpoint{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Split) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHosts := "[]*Endpoint{"
	for _, f := range this.Hosts {
		repeatedStringForHosts += strings.Replace(f.String(), "Endpoint", "Endpoint", 1) + ","
	}
	repeatedStringForHosts += "}"
	s := strings.Join([]string{`&Split{`,
		`SplitID:` + fmt.Sprintf("%v", this.SplitID) + `,`,
		`Hosts:` + repeatedStringForHosts + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRowsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRowsRequest{`,
		`SplitID:` + fmt.Sprintf("%v", this.SplitID) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`MaxBytes:` + fmt.Sprintf("%v", this.MaxBytes) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRowsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]*Column{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(f.String(), "Column", "Column", 1) + ","
	}
	repeatedStringForColumns += "}"
	s := strings.Join([]string{`&GetRowsResponse{`,
		`Columns:` + repeatedStringForColumns + `,`,
		`RowCount:` + fmt.Sprintf("%v", this.RowCount) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Int32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Int32{`,
		`Int32:` + strings.Replace(fmt.Sprintf("%v", this.Int32), "ColumnOfInt32", "ColumnOfInt32", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Int64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Int64{`,
		`Int64:` + strings.Replace(fmt.Sprintf("%v", this.Int64), "ColumnOfInt64", "ColumnOfInt64", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Float64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Float64{`,
		`Float64:` + strings.Replace(fmt.Sprintf("%v", this.Float64), "ColumnOfFloat64", "ColumnOfFloat64", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_String_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_String_{`,
		`String_:` + strings.Replace(fmt.Sprintf("%v", this.String_), "ColumnOfString", "ColumnOfString", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Bool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Bool{`,
		`Bool:` + strings.Replace(fmt.Sprintf("%v", this.Bool), "ColumnOfBools", "ColumnOfBools", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Time) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Time{`,
		`Time:` + strings.Replace(fmt.Sprintf("%v", this.Time), "ColumnOfInt64", "ColumnOfInt64", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Json) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Json{`,
		`Json:` + strings.Replace(fmt.Sprintf("%v", this.Json), "ColumnOfString", "ColumnOfString", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfInt32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfInt32{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Ints:` + fmt.Sprintf("%v", this.Ints) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfInt64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfInt64{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Longs:` + fmt.Sprintf("%v", this.Longs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfFloat64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfFloat64{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Doubles:` + fmt.Sprintf("%v", this.Doubles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfBools) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfBools{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Bools:` + fmt.Sprintf("%v", this.Bools) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfString) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfString{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Sizes:` + fmt.Sprintf("%v", this.Sizes) + `,`,
		`Bytes:` + fmt.Sprintf("%v", this.Bytes) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTalaria(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Batch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &IngestRequest_Batch{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Data = &IngestRequest_Orc{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Data = &IngestRequest_Csv{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &IngestRequest_Url{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = make(map[uint32][]byte)
			}
			var mapkey uint32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthTalaria
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthTalaria
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalaria(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalaria
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Strings[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = make(map[uint32]*Value)
			}
			var mapkey uint32
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTalaria
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTalaria
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalaria(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalaria
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Value[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int32{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int64{v}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Value_Float64{float64(math.Float64frombits(v))}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_String_{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Value_Bool{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Time{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Json{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &TableMeta{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnMeta{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSplitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSplitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSplitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSplits", wireType)
			}
			m.MaxSplits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSplits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSplitsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSplitsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSplitsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Splits = append(m.Splits, &Split{})
			if err := m.Splits[len(m.Splits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Split) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Split: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Split: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitID = append(m.SplitID[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitID == nil {
				m.SplitID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, &Endpoint{})
			if err := m.Hosts[len(m.Hosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitID = append(m.SplitID[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitID == nil {
				m.SplitID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCount", wireType)
			}
			m.RowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfInt32{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Int32{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfInt64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Int64{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfFloat64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Float64{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_String_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfBools{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Bool{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfInt64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Time{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Json{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfInt32) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfInt32: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfInt32: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ints = append(m.Ints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ints) == 0 {
					m.Ints = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ints = append(m.Ints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfInt64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfInt64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfInt64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Longs = append(m.Longs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Longs) == 0 {
					m.Longs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Longs = append(m.Longs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfFloat64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfFloat64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfFloat64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Doubles = append(m.Doubles, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Doubles) == 0 {
					m.Doubles = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Doubles = append(m.Doubles, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfBools) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfBools: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfBools: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Bools = append(m.Bools, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Bools) == 0 {
					m.Bools = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Bools = append(m.Bools, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Bools", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTalaria
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTalaria(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTalaria
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTalaria
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTalaria
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTalaria        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTalaria          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTalaria = fmt.Errorf("proto: unexpected end of group")
)
